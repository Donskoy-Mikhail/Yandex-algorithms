"""
89200209


---Принцип работы-----
Используем стек чтобы запоминать числа для операций
если встретилось число то добавляем его в стек если
встретилась операция то достаем два элемента из стека
и произовдим операцию а результат добавляем в стек
и так до тех пор пока не закончатся элементы в нотации


-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
За счет того что стек работает по принципо FIFO мы можем
забирать числа для совершения в том порядке в котором подразумевает нотация
и далее записывать результат наверх после совершения операции, это значит
что итоговый результат всегда будет сверху что позволяет нам просто снять его
после того как закончились элементы в польской нотации и вывести как ответ


-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Каждый элемент в нотации требует обработки что значит для каждого из
n элементов нужно выполнить одну из операций:

- добавление в стек 0(1)
- выполнение оперции что занимает не более константного времени поскольку
  извлечение двух элементов из стека занимает O(1) и операция над ними O(1)

Итого временная сложность будет O(n)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Для хранения n элементов из нотации потребуется не более чем O(n)
пространства поскольку для хранения мы используем стек в котором мы используем
массив
"""


class Stack:
    def __init__(self):
        self.stack = []
        self.size = 0
            
    def push(self, x):
        self.stack.append(x)
        self.size += 1

    def pop(self):
        x = self.stack.pop()
        self.size += 1
        return x


def calc_polish(pol_not):
    memory = Stack()
    for i in range(len(pol_not)):
        if pol_not[i] not in ["+", "-", "*", "/"]:
            memory.push(int(pol_not[i]))
        else:
            val2 = memory.pop()
            val1 = memory.pop()
            memory.push(eval(f'{val1} {pol_not[i] if pol_not[i] != "/" else "//"} {val2}'))

    return memory.pop()
            
            
if __name__ == "__main__":
    to_calc = list(map(str, input().strip().split()))
    print(calc_polish(to_calc))
