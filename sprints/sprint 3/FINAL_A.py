"""
89475402

-- ПРИНЦИП РАБОТЫ --
Принцип аналогичен тому как мы ищем в массиве обыным бинарным поиском только
мы дополнительно модифицировали его чтобы можно было применить на свдивнутом массиве

За счет того что сдивнутая часть берется сначала то любой элемент сдвинутой части
будет меньше части не сдвинутой и этим можно пользоваться чтобы задать верное напраление
при поиске элемента бинарным поиском

 -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Допустим что элемент оказался в сдвиенотой части то мы найдем его за счет того
что наши указатели на первом этапе определяют попала ли середина в нужную часть
(nums[mid] < target <= nums[right] или nums[left] <= target < nums[mid]
в зависимоти от того где наш средний элемент nums[mid] < nums[right])
 и если попадание произошла не в ту чать то будет идти корректировка середины до тех пор
 пока часть не будет нужной как только середин оказалась в нужной части (что мы определяем
 крайними элементами) то далее мы по сути проводим самый обычный бинарный поиск

Также будет работать и для случае если элемент попал в не сдвинутую часть

Таким образом мы точно определяем нужную часть в которой потом проводим бинарный поиск

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
За счет того мы также каждый раз уменьшаем зону посика в 2 раза алгоритм работает за O(log n)
конечно у нас на каждой итерации для сокращения посика появляются проверки на часть сломаного массива
но они занимают не более чем константоное вреся потому не влияют на время существенно

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Два указателя занимают не более чем констаное место O(1)
И также массив занимает O(n)
Итог O(n)
"""

from typing import List


def broken_search(nums: List[int], target: int) -> int:
    left = 0
    right = len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] < nums[right]:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
        else:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
    return - 1


