"""
90422678

-- ПРИНЦИП РАБОТЫ --

Идея решения состоит в том чтобы инвертировать веса ребер и решать задачу
алгоритмом Прима, поскольку поиск минимального оставного дерева удовлетворяет
нашей задаче из-за инверсии весов

Для хранения путей и поиска вершины с минимальным путем используется куча
Для хранения минимальных

 -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Чтобы найти максимальное остовное веса рёбер в исходном графе инвертируются
. Это делается, чтобы алгоритм Прима, который ищет минимальное остовное дерево,
мог быть использован для поиска максимального остовного дерева.
Граф представляется в виде списка смежности,
где каждая вершина представлена списком своих соседей, а также весами рёбер,
соединяющих вершины.

Алгоритм Прима начинается с выбора начальной вершины и построения остовного дерева,
постепенно добавляя кратчайшие рёбра, связывающие вершины дерева с вершинами вне дерева.
Операции добавления рёбер в остовное дерево и обновления списка кратчайших рёбер
выполняются с использованием мин-кучи (heap).

После завершения алгоритма Прима получается минимальное остовное дерево в  графе,
и его модуль веса равен модулю максимального веса остовного дерева в исходном графе.

Чтобы провести проверку на связность во время добавления вершины в остовное дерево я
прибляю к счетку вершин остовного дерева единицу и если счетчик не равен числу вершин
в исходном дереве то получается что граф несвязный, поскольку алгоритм Прима не может построить
остовное дерево для несвязного графа

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Основным алгоритмом в решении по времени является алгоритм Прима что имеет
сложность O(E log V), где E - количество рёбер, а V - количество вершин в графе
за счет использования кучи

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Для реализации используется дополнительное пространство для хранения графа O(V + E),
мин-кучи, списков посещённых вершин O(V) и некоторых вспомогательных числовых переменных O(1).
В худшем случае, это  O(V + E)  пространства.

"""
import heapq


def max_ostov(n, graph):

    visited = [False] * n
    max_weight = 0
    nodecount = 0
    heap = [(0, 0)]
    while heap:
        weight, vertex = heapq.heappop(heap)
        if visited[vertex]:
            continue
        visited[vertex] = True
        nodecount += 1
        max_weight += weight

        for neighbor, w in graph[vertex]:
            if not visited[neighbor]:
                heapq.heappush(heap, (w, neighbor))

    if nodecount != n:
        return 0
    else:
        return max_weight


if __name__ == "__main__":
    n, m = map(int, input().split())
    graph = [[] for _ in range(n)]

    for _ in range(m):
        u, v, w = map(int, input().split())
        graph[u - 1].append((v - 1, -w))
        graph[v - 1].append((u - 1, -w))

    if n == 1:
        print(0)
    else:
        result = max_ostov(n, graph)
        if result == 0:
            print("Oops! I did it again")
        else:
            print(abs(result))
