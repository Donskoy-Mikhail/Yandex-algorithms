"""
95006896

-- ПРИНЦИП РАБОТЫ --
Алгоритм  для решения этой задачи использует идею о поиске подмножества элементов,
сумма которых равна половине общей суммы всех элементов (если эта сумма четная)


 -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Сначала мы суммируем все очки, которые получил Гоша, и сохраняем эту сумму в total_score.
Если сумма total_score нечетная, то разделение на две равные части невозможно, и мы возвращаем False.
Мы создаем массив dp длинной (total_score // 2 + 1).
Этот массив будет использоваться для хранения информации о том,
можно ли получить сумму, равную индексу массива, используя некоторое подмножество очков.
Инициализируем dp[0] в True, потому что всегда можно получить сумму 0 без использования каких-либо очков.
Для каждого очка мы перебираем значения в массиве dp в обратном порядке (от half_sum до score) и обновляем их.
Если dp[half_sum] установлено в True, это означает, что можно разделить сумму очков на две равные части,
и функция возвращает True. В противном случае функция возвращает False, так как разделение невозможно.
Таким образом, алгоритм проверяет все возможные комбинации подмножеств очков,
чтобы определить, можно ли разделить их на две равные части с одинаковой суммой.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

O(n * total_score // 2), где n - количество очков, а total_score - сумма всех очков

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

O(total_score // 2), где total_score - сумма всех очков
"""


def can_partition_scores(n, scores):
    total_score = sum(scores)

    if total_score % 2 != 0:
        return False

    half_sum = total_score // 2
    dp = [False] * (half_sum + 1)
    dp[0] = True

    for score in scores:
        for i in range(half_sum, score - 1, -1):
            dp[i] = dp[i] or dp[i - score]

    return dp[half_sum]


if __name__ == "__main__":
    n = int(input())
    scores = list(map(int, input().split()))

    result = can_partition_scores(n, scores)
    print(result)
