"""
95467228

-- ПРИНЦИП РАБОТЫ --

Принцип паботы основан на рекурсивном
алгоритме распаковки строки и поиске наибольшего общего префикса среди распакованных строк.

 -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Сам алгоритм решения разбит на две части:

unpack - Эта функция рекурсивно распаковывает строку symbols.
Она начинает с пустой строки result и проходит по символам symbols с помощью индекса i.
Если текущий символ является цифрой, то функция извлекает число (повторение) и
вызывает себя рекурсивно для следующей части строки. Затем она умножает результат
на число и добавляет к result. Если символ не является цифрой, он просто добавляется к result.
Функция продолжает выполнение, пока не встретит символ ']', который указывает на конец текущей
упакованной строки. Эта функция возвращает распакованную строку и новое значение индекса i.

search_pref - Эта функция находит наибольший общий префикс
среди распакованных строк, ограниченный длиной min_length. Она начинает с пустой строки
common_prefix и проходит по каждой позиции в строках. Если все символы на текущей позиции
равны между всеми распакованными строками, символ добавляется к common_prefix.
Иначе цикл прерывается, так как нашли наибольший общий префикс.


-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

unpack работает за O(n), где n - длина входной строки,
В худшем случае, эта рекурсия будет вызываться для каждого символа
во входной строке.

search_pref работает за O(min_length * K) - где К количество строк а
min_length - минимальная длинна строки
так происходит поскольку алгоритм проходит по символам в каждой строке
до минимальной длины min_length и сравнивает их

Итоговая временная сложность -
O(max_len*k) - за распаковку строк, где max_len - максимальная длина входной строки,
k - количество строк
+
O(min_length * K) занимает поиск префикса, - где К количество строк а
min_length - минимальная длинна строки

==> O(max_len*k + min_length * K) ==> 0(k * (max_len + min_length))
где max_len - максимальная длина входной строки,
k - количество строк, min_length - минимальная длинна строки

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Для каждого вызова recursive_unpack создается стековый фрейм,
который хранит локальные переменные.
Таким образом, пространственная сложность unpack функции может быть до O(N),
где N - общая длина распакованных строк.

Функция search_pref - создает только константную по обьему переменную char и
common_prefix равную наибольшему общему префиксу.

Общая пространственная сложность алгоритма определяется максимальным
использованием стековой памяти в unpack функции и составляет O(N),
где N - общая длина распакованных строк

"""


def unpack(symbols):
    s_l = len(symbols)

    def recursive_unpack(i):
        result = ''
        while i < s_l and symbols[i] != ']':
            if symbols[i].isdigit():
                digit = int(symbols[i])
                i += 1
                sub_result, i = recursive_unpack(i + 1)
                result += sub_result * digit
            else:
                result += symbols[i]
                i += 1
        return result, i + 1

    return recursive_unpack(0)[0]


def search_pref(min_length, unpacked_strings):
    common_prefix = ""

    for i in range(min_length):
        char = unpacked_strings[0][i]
        if all(s[i] == char for s in unpacked_strings):
            common_prefix += char
        else:
            break
    return common_prefix


if __name__ == "__main__":
    n = int(input())
    packed_strings = []
    for _ in range(n):
        packed_strings.append(input())

    unpacked_strings = [unpack(s) for s in packed_strings]
    min_length = min(len(s) for s in unpacked_strings)

    res = search_pref(min_length, unpacked_strings)
    print(res)
