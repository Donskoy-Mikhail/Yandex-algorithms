"""
95320568

-- ПРИНЦИП РАБОТЫ --

Этот код работает на основе динамического программирования. Он успешно проверяет,
можно ли разбить строку T на слова из множества words, так как он учитывает
возможность разбиения строки с помощью слов из словаря и проверяет все
варианты разбиения. Если dp[len(T)] равно True, это означает, что разбиение возможно.

 -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Алгоритм работает следующим способом:

1. Преобразует список words в множество для эффективного поиска.
2. Создает массив dp, где dp[i] указывает, можно ли разбить T до i-го символа на слова из словаря.
3. Перебирает T посимвольно и проверяет, можно ли разбить подстроку до текущей позиции i.
4. Если да, устанавливает dp[i] в True.
5. В конце, если dp[len(T)] истинно, выводит "YES", иначе "NO".

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --

Поскольку есть два вложенных цикла. Внешний цикл выполняется n раз,
а внутренний цикл выполняется m раз, где m - максимальная длина слова n- длина T.
Итоговая временная сложность алгоритма - O(n * m * m)


-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

Пространственная сложность алгоритма - O(n + k),
где n - длина строки T, k - количество слов в словаре

"""

import sys


def can_be_split(T, words):
    word_set = set(words)
    dp = [False] * (len(T) + 1)
    dp[0] = True
    max_word_length = max(len(word) for word in words)

    for i in range(1, len(T) + 1):
        for j in range(1, min(i, max_word_length) + 1):
            if dp[i - j] and T[i - j:i] in word_set:
                dp[i] = True
                break

    return dp[len(T)]


if __name__ == "__main__":
    T = sys.stdin.readline().rstrip()
    n = int(sys.stdin.readline().rstrip())
    words = [sys.stdin.readline().rstrip() for _ in range(n)]

    if can_be_split(T, words):
        print("YES")
    else:
        print("NO")
